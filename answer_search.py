#!/usr/bin/env python3
# coding: utf-8
# File: answer_search.py
# Date: 25-6-6

import os # 导入os模块，用于处理环境变量
import logging # 导入logging模块，用于日志记录
from py2neo import Graph
from dotenv import load_dotenv

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler()  # 输出到控制台
    ]
)
logger = logging.getLogger(__name__)

# 加载环境变量
dotenv_path = os.path.join(os.path.dirname(__file__), '.env')
if os.path.exists(dotenv_path):
    load_dotenv(dotenv_path)

class AnswerSearcher: # 定义一个名为AnswerSearcher的类
    def __init__(self): # 定义类的构造函数
        # 从环境变量中获取Neo4j连接信息，如果不存在则使用默认值
        neo4j_uri = os.getenv("NEO4J_URI", "bolt://localhost:7687")
        neo4j_user = os.getenv("NEO4J_USER", "neo4j")
        neo4j_password = os.getenv("NEO4J_PASSWORD", "neo4j")
        
        try:
            self.g = Graph( # 初始化Graph对象，连接到Neo4j数据库
                uri=neo4j_uri, # Neo4j数据库的URI，从环境变量获取
                auth=(neo4j_user, neo4j_password)) # Neo4j数据库的认证信息，从环境变量获取
            logger.info("成功连接到Neo4j数据库")
        except Exception as e:
            logger.error(f"连接Neo4j数据库失败: {e}")
            # 仍然创建Graph对象，但可能会在后续查询时失败
            self.g = Graph(uri=neo4j_uri, auth=(neo4j_user, neo4j_password))
        self.num_limit = 20 # 定义一个数字限制，用于在列表答案中显示的最大项目数（例如多个症状）

    '''执行cypher查询，并返回相应结果''' # 方法的文档字符串，说明其功能
    def search_main(self, sqls): # 定义search_main方法，接收一个包含Cypher查询语句的列表作为参数
        final_answers = [] # 初始化一个空列表，用于存储最终的答案
        for sql_ in sqls: # 遍历传入的Cypher查询语句列表中的每一个元素
            question_type = sql_['question_type'] # 获取当前查询语句对应的问题类型
            queries = sql_['sql'] # 获取当前问题类型对应的Cypher查询语句列表
            answers = [] # 初始化一个空列表，用于存储从Neo4j查询到的原始结果
            for query in queries: # 遍历当前问题类型下的每一个Cypher查询语句
                try: # 尝试执行查询
                    ress = self.g.run(query).data() # 执行Cypher查询，并获取返回的数据
                    answers.extend(ress) # 将查询结果追加到answers列表中（使用extend是因为ress本身可能是一个包含多个字典的列表）
                except Exception as e: # 如果执行查询时发生异常
                    logger.error(f"执行Cypher查询出错 '{query}': {e}") # 使用logger记录错误信息，包括出错的查询语句和异常详情
            
            if answers: # 如果查询到了结果 (answers列表不为空)
                final_answer = self.answer_prettify(question_type, answers) # 调用answer_prettify方法美化答案
                if final_answer: # 如果美化后的答案不为空
                    final_answers.append(final_answer) # 将美化后的答案添加到最终答案列表中
            elif queries: # 如果存在查询语句但是没有查询到答案
                try: # 尝试从第一条查询语句中提取实体名称
                    first_query = queries[0] # 获取第一条查询语句
                    # Attempt to extract entity name, assuming format "a.name = '...' " # 尝试提取实体名称，假设格式为 "a.name = '...'"
                    entity_name_start = first_query.find("a.name = '") + len("a.name = '") # 查找实体名称的起始位置
                    entity_name_end = first_query.find("'", entity_name_start) # 查找实体名称的结束位置
                    entity_name = first_query[entity_name_start:entity_name_end] if entity_name_start > len("a.name = '") -1 and entity_name_end > entity_name_start else "该景点" # 提取实体名称，如果提取失败则默认为"该景点"
                    final_answers.append(f"抱歉，没有找到关于“{entity_name}”的“{question_type}”信息。") # 添加未找到信息的提示
                except Exception: # Fallback if entity name extraction fails # 如果实体名称提取失败
                    final_answers.append(f"抱歉，没有找到关于该问题的相关信息 (类型: {question_type})。") # 添加通用的未找到信息提示
        
        if not final_answers and sqls: # If no specific answers were generated but there were queries # 如果没有生成具体的答案但是有查询语句
            final_answers.append("抱歉，未能根据您的问题找到明确的答案。请尝试更具体的问题或检查景点名称是否正确。") # 添加通用的未找到明确答案的提示
        elif not sqls: # If no SQLs were generated by the parser # 如果问题解析器没有生成任何SQL查询语句
             final_answers.append("抱歉，我无法理解您的问题。") # 添加无法理解问题的提示


        return final_answers # 返回最终的答案列表

    '''根据对应的qustion_type，调用相应的回复模板''' # 方法的文档字符串，说明其功能
    def answer_prettify(self, question_type, answers): # 定义answer_prettify方法，接收问题类型和查询结果作为参数
        # answers is a list of dictionaries, e.g., [{'name': '武侯祠', '地址': '武侯祠大街231号'}] # 参数answers的格式示例
        
        final_answer_parts = [] # 初始化一个空列表，用于存储美化后的答案片段

        if not answers: # 如果查询结果为空
            return "" # 返回空字符串

        for ans_item in answers: # ans_item is a dict like {'name': '武侯祠', '地址': '...'} # 遍历查询结果列表中的每一个字典项
            subject_name = ans_item.get('name', '该景点') # Default if 'name' is not in results # 获取字典中的'name'字段作为主题名称，如果不存在则默认为'该景点'

            # Property names here (e.g., '地址', '开放时间') must match the ALIASES in Cypher queries # 此处的属性名（例如 '地址', '开放时间'）必须与Cypher查询中的别名匹配
            # from question_parser.py (e.g., RETURN a.地址 AS 地址) # 例如来自question_parser.py中的 RETURN a.地址 AS 地址

            if question_type == '地址': # 如果问题类型是'地址'
                value = ans_item.get('地址') # 获取地址信息
                if value: # 如果地址信息存在
                    final_answer_parts.append(f"{subject_name}的地址是：{value}。") # 构建答案字符串并添加到列表中
                else: # 如果地址信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的地址信息。") # 构建未找到信息的提示并添加到列表中

            elif question_type == '开放时间': # 如果问题类型是'开放时间'
                value = ans_item.get('开放时间') # 获取开放时间信息
                if value: # 如果开放时间信息存在
                    final_answer_parts.append(f"{subject_name}的开放时间是：{value}。") # 构建答案字符串
                else: # 如果开放时间信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的开放时间信息。") # 构建未找到信息的提示

            elif question_type == '电话': # 如果问题类型是'电话'
                value = ans_item.get('电话') # 获取电话信息
                if value: # 如果电话信息存在
                    final_answer_parts.append(f"{subject_name}的联系电话是：{value}。") # 构建答案字符串
                else: # 如果电话信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的电话信息。") # 构建未找到信息的提示

            elif question_type == '评分': # 如果问题类型是'评分'
                value = ans_item.get('评分') # 获取评分信息
                if value is not None:  # 检查评分值是否存在 (可能是0分，所以用 is not None)
                    final_answer_parts.append(f"{subject_name}的评分是：{value}。") # 构建答案字符串
                else: # 如果评分信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的评分信息。") # 构建未找到信息的提示

            elif question_type == '热度': # 如果问题类型是'热度'
                value = ans_item.get('热度') # 获取热度信息
                if value is not None: # 检查热度值是否存在
                    final_answer_parts.append(f"{subject_name}的热度是：{value}。") # 构建答案字符串
                else: # 如果热度信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的热度信息。") # 构建未找到信息的提示

            elif question_type == '官网': # 如果问题类型是'官网'
                value = ans_item.get('官网') # 获取官网信息
                if value: # 如果官网信息存在
                    final_answer_parts.append(f"{subject_name}的官网是：{value}。") # 构建答案字符串
                else: # 如果官网信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的官网信息。") # 构建未找到信息的提示
            
            elif question_type == '门票价格': # 如果问题类型是'门票价格'
                value = ans_item.get('门票价格') # 获取门票价格信息
                if value: # 如果门票价格信息存在
                    final_answer_parts.append(f"{subject_name}的门票价格是：{value}。") # 构建答案字符串
                else: # 如果门票价格信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的门票价格信息。") # 构建未找到信息的提示
            
            elif question_type == '简介': # Handles the '简介' type # 如果问题类型是'简介'
                value = ans_item.get('introduction') # 使用 'introduction' 作为键获取简介信息
                if value: # 如果简介信息存在
                    final_answer_parts.append(f"{subject_name}的简介：{value}") # 构建答案字符串
                else: # 如果简介信息不存在
                    final_answer_parts.append(f"抱歉，未能查询到{subject_name}的简介信息。") # 构建未找到信息的提示
            
            else: # 如果问题类型未被以上条件处理
                # Fallback for unhandled question types for this attraction # 针对此景点的未处理问题类型的回退方案
                # This case might indicate a mismatch between classifier, parser, and searcher # 这种情况可能表明分类器、解析器和搜索器之间存在不匹配
                final_answer_parts.append(f"抱歉，我暂时无法回答关于{subject_name}的“{question_type}”问题。请检查问题类型是否支持。") # 构建无法回答的提示

        return "\\n".join(final_answer_parts) if final_answer_parts else "" # 将答案片段列表用换行符连接成一个字符串返回，如果列表为空则返回空字符串


if __name__ == '__main__': # 如果当前脚本是作为主程序运行
    searcher = AnswerSearcher() # 创建AnswerSearcher类的实例